import { ethers, network, run } from "hardhat";

/**
 * Deployment Script for {{CONTRACT_NAME}}
 * Generated by Cursor Agent Factory - Solidity Ethereum Blueprint
 * 
 * Usage:
 *   npx hardhat run scripts/deploy.ts --network <network>
 * 
 * Environment variables required:
 *   - PRIVATE_KEY: Deployer private key
 *   - ETHERSCAN_API_KEY: For contract verification
 */

interface DeploymentConfig {
  // Add constructor parameters here
  param1: string;
  param2: number;
}

// Network-specific configurations
const configs: Record<string, DeploymentConfig> = {
  mainnet: {
    param1: "production-value",
    param2: 1000,
  },
  sepolia: {
    param1: "test-value",
    param2: 100,
  },
  localhost: {
    param1: "local-value",
    param2: 10,
  },
};

async function main() {
  // Get deployer account
  const [deployer] = await ethers.getSigners();
  console.log("Deploying contracts with account:", deployer.address);

  const balance = await ethers.provider.getBalance(deployer.address);
  console.log("Account balance:", ethers.formatEther(balance), "ETH");

  // Get network-specific config
  const networkName = network.name;
  const config = configs[networkName] || configs.localhost;
  console.log(`Using ${networkName} configuration`);

  // Deploy contract
  console.log("\nDeploying {{CONTRACT_NAME}}...");
  
  const ContractFactory = await ethers.getContractFactory("{{CONTRACT_NAME}}");
  const contract = await ContractFactory.deploy(
    config.param1,
    config.param2
    // Add constructor arguments
  );

  await contract.waitForDeployment();
  const contractAddress = await contract.getAddress();

  console.log("{{CONTRACT_NAME}} deployed to:", contractAddress);

  // Wait for confirmations before verification
  if (networkName !== "localhost" && networkName !== "hardhat") {
    console.log("\nWaiting for block confirmations...");
    await contract.deploymentTransaction()?.wait(5);

    // Verify on Etherscan
    console.log("\nVerifying contract on Etherscan...");
    try {
      await run("verify:verify", {
        address: contractAddress,
        constructorArguments: [
          config.param1,
          config.param2,
          // Add constructor arguments
        ],
      });
      console.log("Contract verified successfully!");
    } catch (error: any) {
      if (error.message.includes("Already Verified")) {
        console.log("Contract already verified!");
      } else {
        console.error("Verification failed:", error.message);
      }
    }
  }

  // Log deployment summary
  console.log("\n========== Deployment Summary ==========");
  console.log(`Network: ${networkName}`);
  console.log(`Contract: {{CONTRACT_NAME}}`);
  console.log(`Address: ${contractAddress}`);
  console.log(`Deployer: ${deployer.address}`);
  console.log(`Gas used: ${(await contract.deploymentTransaction()?.wait())?.gasUsed}`);
  console.log("==========================================");

  // Save deployment info
  const deploymentInfo = {
    network: networkName,
    contract: "{{CONTRACT_NAME}}",
    address: contractAddress,
    deployer: deployer.address,
    timestamp: new Date().toISOString(),
    config,
  };

  console.log("\nDeployment info:", JSON.stringify(deploymentInfo, null, 2));
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
