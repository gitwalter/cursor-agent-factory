// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title {{NFT_NAME}}
 * @author {{AUTHOR}}
 * @notice ERC721 NFT implementation with metadata, royalties, and enumeration
 * @dev Generated by Cursor Agent Factory - Solidity Ethereum Blueprint
 * 
 * Axiom Alignment:
 * - A1 (Verifiability): All mints and transfers emit events
 * - A3 (Transparency): On-chain royalty information
 * - A4 (Non-Harm): Uses audited OpenZeppelin contracts
 */

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract {{CONTRACT_NAME}} is
    ERC721,
    ERC721Enumerable,
    ERC721URIStorage,
    ERC721Royalty,
    Ownable
{
    using Strings for uint256;

    /// @notice Maximum supply (0 = unlimited)
    uint256 public immutable maxSupply;

    /// @notice Current token ID counter
    uint256 private _nextTokenId;

    /// @notice Mint price in wei
    uint256 public mintPrice;

    /// @notice Base URI for token metadata
    string private _baseTokenURI;

    /// @notice Whether minting is paused
    bool public mintPaused;

    /// @notice Emitted when a token is minted
    event NFTMinted(
        address indexed to,
        uint256 indexed tokenId,
        string tokenURI
    );

    /// @notice Emitted when mint price is updated
    event MintPriceUpdated(uint256 oldPrice, uint256 newPrice);

    /// @notice Emitted when base URI is updated
    event BaseURIUpdated(string newBaseURI);

    /**
     * @notice Contract constructor
     * @param name_ NFT collection name
     * @param symbol_ NFT collection symbol
     * @param maxSupply_ Maximum supply (0 for unlimited)
     * @param mintPrice_ Initial mint price in wei
     * @param royaltyReceiver_ Address to receive royalties
     * @param royaltyBps_ Royalty in basis points (e.g., 250 = 2.5%)
     * @param initialOwner_ Contract owner
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint256 maxSupply_,
        uint256 mintPrice_,
        address royaltyReceiver_,
        uint96 royaltyBps_,
        address initialOwner_
    ) ERC721(name_, symbol_) Ownable(initialOwner_) {
        require(initialOwner_ != address(0), "Invalid owner");
        require(royaltyBps_ <= 1000, "Royalty too high"); // Max 10%

        maxSupply = maxSupply_;
        mintPrice = mintPrice_;

        if (royaltyReceiver_ != address(0)) {
            _setDefaultRoyalty(royaltyReceiver_, royaltyBps_);
        }
    }

    /**
     * @notice Mint a new NFT
     * @param to Recipient address
     * @param uri Token metadata URI
     * @return tokenId The minted token ID
     */
    function mint(
        address to,
        string memory uri
    ) external payable returns (uint256 tokenId) {
        require(!mintPaused, "Minting paused");
        require(to != address(0), "Mint to zero address");
        require(msg.value >= mintPrice, "Insufficient payment");
        require(
            maxSupply == 0 || _nextTokenId < maxSupply,
            "Max supply reached"
        );

        tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);

        emit NFTMinted(to, tokenId, uri);

        // Refund excess payment
        if (msg.value > mintPrice) {
            payable(msg.sender).transfer(msg.value - mintPrice);
        }
    }

    /**
     * @notice Batch mint NFTs (owner only)
     * @param to Recipient address
     * @param uris Array of token URIs
     */
    function batchMint(
        address to,
        string[] memory uris
    ) external onlyOwner {
        require(to != address(0), "Mint to zero address");
        require(
            maxSupply == 0 || _nextTokenId + uris.length <= maxSupply,
            "Exceeds max supply"
        );

        for (uint256 i = 0; i < uris.length; i++) {
            uint256 tokenId = _nextTokenId++;
            _safeMint(to, tokenId);
            _setTokenURI(tokenId, uris[i]);
            emit NFTMinted(to, tokenId, uris[i]);
        }
    }

    /**
     * @notice Set mint price
     * @param newPrice New mint price in wei
     */
    function setMintPrice(uint256 newPrice) external onlyOwner {
        uint256 oldPrice = mintPrice;
        mintPrice = newPrice;
        emit MintPriceUpdated(oldPrice, newPrice);
    }

    /**
     * @notice Set base URI for metadata
     * @param baseURI New base URI
     */
    function setBaseURI(string memory baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
        emit BaseURIUpdated(baseURI);
    }

    /**
     * @notice Toggle minting pause
     */
    function toggleMintPause() external onlyOwner {
        mintPaused = !mintPaused;
    }

    /**
     * @notice Withdraw contract balance
     */
    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance");
        payable(owner()).transfer(balance);
    }

    // ============ Required Overrides ============

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function _update(
        address to,
        uint256 tokenId,
        address auth
    ) internal override(ERC721, ERC721Enumerable) returns (address) {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(
        address account,
        uint128 value
    ) internal override(ERC721, ERC721Enumerable) {
        super._increaseBalance(account, value);
    }

    function tokenURI(
        uint256 tokenId
    ) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        override(ERC721, ERC721Enumerable, ERC721URIStorage, ERC721Royalty)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
