/**
 * ${SERVICE_NAME} Service Handler - TypeScript Implementation
 * 
 * Purpose: Implement business logic and event handlers for ${SERVICE_NAME} service
 * Author: ${AUTHOR}
 * Created: ${DATE}
 * 
 * This handler implements custom business logic, validations, and side effects
 * for the ${SERVICE_NAME} service. It follows CAP best practices for BTP deployment.
 * 
 * @see https://cap.cloud.sap/docs/node.js/services#event-handlers
 */

import cds from '@sap/cds';
import { Request, Service } from '@sap/cds/apis/services';

/**
 * Type definitions for service entities
 * 
 * These types are typically auto-generated by CAP from your CDS definitions.
 * For now, we define them manually for type safety.
 */
type ${ENTITY_NAME} = {
    ID: string;
    name: string;
    description?: string;
    status: string;
    createdAt?: Date;
    createdBy?: string;
    modifiedAt?: Date;
    modifiedBy?: string;
};

/**
 * Service handler for ${SERVICE_NAME}.
 * 
 * Event handlers are registered using the 'on' method:
 * - 'CREATE', 'READ', 'UPDATE', 'DELETE' for CRUD operations
 * - 'before', 'after' modifiers for timing control
 * - Custom actions and functions
 * 
 * @module srv/${SERVICE_NAME}
 */
export default class ${SERVICE_NAME}Service extends cds.ApplicationService {
    /**
     * Initialize service and register event handlers
     */
    async init() {
        const { ${ENTITY_NAME} } = this.entities as {
            ${ENTITY_NAME}: typeof cds.entities['${NAMESPACE}.${ENTITY_NAME}']
        };

        /**
         * Before CREATE handler - validation and data transformation
         * 
         * Use for:
         * - Input validation
         * - Data enrichment
         * - Authorization checks
         * - Setting default values
         */
        this.before('CREATE', ${ENTITY_NAME}, async (req: Request) => {
            const data = req.data as Partial<${ENTITY_NAME}>;

            // Validation example
            if (!data.name || data.name.trim().length === 0) {
                return req.error(400, 'Name is required');
            }

            // Data transformation example
            if (data.name) {
                data.name = data.name.trim();
            }

            // Set default values
            if (!data.status) {
                data.status = 'ACTIVE';
            }

            // Authorization check example
            // const user = req.user;
            // if (!user.hasRole('${REQUIRED_ROLE}')) {
            //     return req.error(403, 'Insufficient permissions');
            // }
        });

        /**
         * After CREATE handler - side effects and notifications
         * 
         * Use for:
         * - Sending notifications
         * - Creating related records
         * - Triggering workflows
         * - Logging audit information
         */
        this.after('CREATE', ${ENTITY_NAME}, async (data: ${ENTITY_NAME}, req: Request) => {
            // Side effect example: Create audit log
            // await cds.run(
            //     INSERT.into('${AUDIT_ENTITY}').entries({
            //         entityType: '${ENTITY_NAME}',
            //         entityId: data.ID,
            //         action: 'CREATE',
            //         userId: req.user.id
            //     })
            // );

            // Side effect example: Send notification
            // await this.sendNotification({
            //     type: 'ENTITY_CREATED',
            //     entityId: data.ID,
            //     userId: req.user.id
            // });
        });

        /**
         * Before UPDATE handler - validation and change tracking
         */
        this.before('UPDATE', ${ENTITY_NAME}, async (req: Request) => {
            const data = req.data as Partial<${ENTITY_NAME}>;

            // Validation example: prevent status change
            if (data.status && (req.data as ${ENTITY_NAME}).status !== data.status) {
                // Check if status transition is allowed
                // const allowedTransitions = this.getStatusTransitions((req.data as ${ENTITY_NAME}).status);
                // if (!allowedTransitions.includes(data.status)) {
                //     return req.error(400, `Status cannot be changed from ${(req.data as ${ENTITY_NAME}).status} to ${data.status}`);
                // }
            }

            // Prevent modification of read-only fields
            if (data.ID) {
                delete data.ID; // ID cannot be changed
            }
        });

        /**
         * After READ handler - data enrichment
         * 
         * Use for:
         * - Adding computed fields
         * - Enriching with related data
         * - Filtering sensitive information
         */
        this.after('READ', ${ENTITY_NAME}, async (results: ${ENTITY_NAME} | ${ENTITY_NAME}[], req: Request) => {
            // Enrichment example: Add computed field
            if (Array.isArray(results)) {
                results.forEach(item => {
                    // (item as any).computedField = this.calculateValue(item);
                });
            } else if (results) {
                // (results as any).computedField = this.calculateValue(results);
            }
        });

        /**
         * Custom action handler
         * 
         * Actions are side-effect operations that can modify data.
         * Define the action in service.cds first.
         */
        // this.on('${ACTION_NAME}', async (req: Request) => {
        //     const { param1, param2 } = req.data as { param1: string; param2: number };
        //
        //     // Business logic here
        //     const result = await this.performAction(param1, param2);
        //
        //     return {
        //         success: true,
        //         result: result
        //     };
        // });

        /**
         * Custom function handler
         * 
         * Functions are read-only operations for queries.
         * Define the function in service.cds first.
         */
        // this.on('${FUNCTION_NAME}', async (req: Request) => {
        //     const { param1 } = req.data as { param1: string };
        //
        //     // Query logic here
        //     const results = await cds.run(
        //         SELECT.from(${ENTITY_NAME}).where({ field: param1 })
        //     );
        //
        //     return results;
        // });

        return super.init();
    }

    /**
     * Helper method example
     * 
     * Extract reusable business logic into helper methods
     * for better testability and maintainability.
     */
    // private async performAction(param1: string, param2: number): Promise<any> {
    //     // Implementation
    //     return { /* result */ };
    // }

    // private async sendNotification(notification: any): Promise<void> {
    //     // Implementation for sending notifications
    //     // Could use messaging service, email, etc.
    // }
}
