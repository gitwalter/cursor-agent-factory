"""
{{AGENT_NAME}} - Tool-Calling Agent Executor

Purpose: {{AGENT_PURPOSE}}
Author: {{AUTHOR}}
Date: {{DATE}}

Axiom Alignment:
- A1 (Verifiability): Tool calls are logged and traceable
- A2 (User Primacy): Agent confirms before consequential actions
- A3 (Transparency): Tool selection reasoning is explicit
- A4 (Non-Harm): Tool usage is validated
"""

from typing import List, Dict, Any, Optional
from langchain_core.tools import tool, Tool
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI
from langchain.agents import create_openai_tools_agent, AgentExecutor
from langchain_core.messages import HumanMessage, AIMessage
from pydantic import BaseModel, Field
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class {{AGENT_CLASS_NAME}}Output(BaseModel):
    """Structured output for agent execution."""
    output: str = Field(description="Final agent output")
    tool_calls: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Tool calls made during execution"
    )
    iterations: int = Field(description="Number of iterations")
    requires_confirmation: bool = Field(
        default=False,
        description="Whether action requires user confirmation (A2)"
    )


# Tool definitions
@tool
def {{TOOL_FUNCTION_NAME}}(input_text: str) -> str:
    """
    {{TOOL_DESCRIPTION}}
    
    Args:
        input_text: Input text to process
    
    Returns:
        Tool output
    """
    logger.info(f"Tool {{TOOL_FUNCTION_NAME}} called with: {input_text[:100]}...")
    # Tool implementation here
    return f"Processed: {input_text}"


class {{AGENT_CLASS_NAME}}:
    """
    {{AGENT_NAME}} - Tool-Calling Agent Executor
    
    Implements a ReAct-style agent that can:
    - Use tools to interact with external systems
    - Reason about which tools to use
    - Iterate until task completion
    
    Example:
        >>> agent = {{AGENT_CLASS_NAME}}()
        >>> result = agent.run("{{EXAMPLE_TASK}}")
        >>> print(result.output)
    """
    
    def __init__(
        self,
        model_name: str = "{{MODEL_NAME}}",
        temperature: float = {{TEMPERATURE}},
        tools: Optional[List[Tool]] = None,
        max_iterations: int = 15,
        max_execution_time: Optional[float] = None,
        verbose: bool = True
    ):
        """
        Initialize agent executor.
        
        Args:
            model_name: LLM model identifier
            temperature: Sampling temperature
            tools: List of tools available to agent
            max_iterations: Maximum agent iterations
            max_execution_time: Maximum execution time in seconds
            verbose: Enable verbose logging
        """
        self.model_name = model_name
        self.temperature = temperature
        self.max_iterations = max_iterations
        self.max_execution_time = max_execution_time
        self.verbose = verbose
        
        # Initialize LLM
        self.llm = ChatOpenAI(
            model=self.model_name,
            temperature=self.temperature
        )
        
        # Default tools if none provided
        self.tools = tools or [{{TOOL_FUNCTION_NAME}}]
        
        # Create prompt
        self.prompt = self._create_prompt()
        
        # Create agent
        self.agent = create_openai_tools_agent(
            llm=self.llm,
            tools=self.tools,
            prompt=self.prompt
        )
        
        # Create executor
        self.executor = AgentExecutor(
            agent=self.agent,
            tools=self.tools,
            verbose=verbose,
            max_iterations=max_iterations,
            max_execution_time=max_execution_time,
            handle_parsing_errors=True,
            return_intermediate_steps=True
        )
        
        logger.info(f"Initialized {{AGENT_NAME}} with {len(self.tools)} tools")
    
    def _create_prompt(self) -> ChatPromptTemplate:
        """Create agent prompt template."""
        system_message = """{{SYSTEM_PROMPT}}

You are {{AGENT_NAME}}, a helpful AI assistant with access to tools.

## Core Principles
- VERIFIABILITY (A1): Log all tool calls and reasoning
- USER PRIMACY (A2): Confirm before consequential actions
- TRANSPARENCY (A3): Explain why you're using each tool
- NON-HARM (A4): Validate tool inputs and outputs

## Available Tools
You have access to the following tools:
{{TOOL_DESCRIPTIONS}}

## Instructions
1. Think step by step about what needs to be done
2. Select the appropriate tool(s) for the task
3. Execute tools and analyze results
4. Iterate until the task is complete
5. Provide a clear final answer

If an action could have significant consequences, ask for user confirmation first (A2).
"""
        
        return ChatPromptTemplate.from_messages([
            ("system", system_message),
            MessagesPlaceholder(variable_name="chat_history"),
            ("human", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad")
        ])
    
    def run(
        self,
        input_text: str,
        chat_history: Optional[List] = None
    ) -> {{AGENT_CLASS_NAME}}Output:
        """
        Run the agent with given input.
        
        Args:
            input_text: User input/task
            chat_history: Optional conversation history
        
        Returns:
            Structured output with result and tool calls
        """
        logger.info(f"Running agent with input: {input_text[:100]}...")
        
        try:
            # Prepare input
            agent_input = {
                "input": input_text,
                "chat_history": chat_history or []
            }
            
            # Execute agent
            result = self.executor.invoke(agent_input)
            
            # Extract tool calls from intermediate steps
            tool_calls = []
            if "intermediate_steps" in result:
                for step in result["intermediate_steps"]:
                    tool_calls.append({
                        "tool": step[0].tool,
                        "input": step[0].tool_input,
                        "output": str(step[1])[:200]  # Truncate long outputs
                    })
            
            # Check if confirmation is needed (A2)
            requires_confirmation = self._check_confirmation_needed(result["output"])
            
            output = {{AGENT_CLASS_NAME}}Output(
                output=result["output"],
                tool_calls=tool_calls,
                iterations=len(tool_calls),
                requires_confirmation=requires_confirmation
            )
            
            logger.info(f"Agent completed in {len(tool_calls)} iterations")
            if tool_calls:
                logger.info(f"Tools used: {[tc['tool'] for tc in tool_calls]}")
            
            return output
            
        except Exception as e:
            logger.error(f"Error during agent execution: {e}")
            return {{AGENT_CLASS_NAME}}Output(
                output=f"Error: {str(e)}",
                tool_calls=[],
                iterations=0,
                requires_confirmation=False
            )
    
    def _check_confirmation_needed(self, output: str) -> bool:
        """
        Check if output indicates confirmation is needed (A2).
        
        Args:
            output: Agent output text
        
        Returns:
            True if confirmation is needed
        """
        confirmation_keywords = [
            "confirm", "approval", "permission", "proceed",
            "delete", "remove", "modify", "change"
        ]
        return any(keyword in output.lower() for keyword in confirmation_keywords)
    
    async def arun(
        self,
        input_text: str,
        chat_history: Optional[List] = None
    ) -> {{AGENT_CLASS_NAME}}Output:
        """Async version of run."""
        logger.info(f"Async running agent with input: {input_text[:100]}...")
        
        try:
            agent_input = {
                "input": input_text,
                "chat_history": chat_history or []
            }
            
            result = await self.executor.ainvoke(agent_input)
            
            tool_calls = []
            if "intermediate_steps" in result:
                for step in result["intermediate_steps"]:
                    tool_calls.append({
                        "tool": step[0].tool,
                        "input": step[0].tool_input,
                        "output": str(step[1])[:200]
                    })
            
            requires_confirmation = self._check_confirmation_needed(result["output"])
            
            return {{AGENT_CLASS_NAME}}Output(
                output=result["output"],
                tool_calls=tool_calls,
                iterations=len(tool_calls),
                requires_confirmation=requires_confirmation
            )
            
        except Exception as e:
            logger.error(f"Error during async agent execution: {e}")
            return {{AGENT_CLASS_NAME}}Output(
                output=f"Error: {str(e)}",
                tool_calls=[],
                iterations=0,
                requires_confirmation=False
            )


# Example usage
if __name__ == "__main__":
    # Create agent
    agent = {{AGENT_CLASS_NAME}}(
        model_name="{{MODEL_NAME}}",
        verbose=True
    )
    
    # Run agent
    result = agent.run("{{EXAMPLE_TASK}}")
    
    print(f"Output: {result.output}")
    print(f"Iterations: {result.iterations}")
    print(f"Tool calls: {len(result.tool_calls)}")
    if result.requires_confirmation:
        print("⚠️  This action requires user confirmation")
