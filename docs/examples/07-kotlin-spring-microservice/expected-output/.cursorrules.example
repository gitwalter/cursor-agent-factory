# Inventory Service - Cursor Agent Rules
# Generated by Cursor Agent Factory
# 5-Layer Architecture for Kotlin Spring Boot

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 0: INTEGRITY & LOGIC (Axioms)
# ═══════════════════════════════════════════════════════════════════════════════

## Core Axioms (Immutable)

### A1: Verifiability
All code must be testable:
- Kotest specs for all services
- MockK for mocking dependencies
- Test coverage >= 85%

### A2: User Primacy
API consumer needs first:
- Clear, RESTful endpoints
- Meaningful error responses
- OpenAPI documentation

### A3: Transparency
Clear reactive flows:
- Explicit Flow and suspend usage
- No hidden blocking calls
- Traceable coroutine contexts

### A4: Non-Harm
Secure endpoints:
- Input validation
- No sensitive data in logs
- Proper error handling

### A5: Consistency
Kotlin conventions throughout:
- Official Kotlin style guide
- Consistent naming patterns
- Uniform project structure

## Optional Axioms (Selected)

### A6: Minimalism
Concise, idiomatic Kotlin:
- Expression bodies for simple functions
- Smart use of null safety operators
- No unnecessary abstractions
- Let Kotlin features reduce boilerplate

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 1: PURPOSE
# ═══════════════════════════════════════════════════════════════════════════════

## Mission
To accelerate Kotlin microservice development with idiomatic patterns and
reactive programming.

## Primary Stakeholders
Kotlin developers building reactive microservices (team of 2-4).

## Success Criteria
Fully reactive, Kotlin-idiomatic microservices with 85% test coverage.

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 2: PRINCIPLES
# ═══════════════════════════════════════════════════════════════════════════════

## Quality Standards

### Kotlin Code Quality
- No platform types (explicit nullability)
- Data classes for DTOs
- Sealed classes for result types
- Extension functions for utilities
- Prefer val over var

### Reactive Quality
- No blocking calls in reactive flows
- Proper backpressure handling
- Context preservation in coroutines
- Structured concurrency

## Kotlin Idioms

### Null Safety
- Use ?. for safe calls
- Use ?: for elvis operator
- Use ?.let {} for conditional execution
- Avoid !! except with explicit justification

### Functional Style
- Use map, filter, fold on collections
- Prefer expression bodies
- Use when for multi-branch logic
- Use scope functions appropriately

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 3: METHODOLOGY
# ═══════════════════════════════════════════════════════════════════════════════

## Development Methodology: Kanban

### Flow Management
- Pull-based work assignment
- WIP limit: 3 items per developer
- Continuous deployment

### Quality Gates
- ktlint check: pass
- Detekt analysis: no critical issues
- Kotest: all tests pass
- Coverage: >= 85%

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 4: TECHNICAL
# ═══════════════════════════════════════════════════════════════════════════════

## Technology Stack

### Language
- Kotlin 1.9+
- JDK 21

### Framework
- Spring Boot 3.2+
- Spring WebFlux
- Kotlin Coroutines 1.8+

### Data Access
- Spring Data R2DBC
- PostgreSQL (prod)
- H2 (test)

### Testing
- Kotest (BDD-style specs)
- MockK (Kotlin mocking)
- WebTestClient (reactive testing)

### Build
- Gradle with Kotlin DSL
- ktlint (linting)
- Detekt (static analysis)

## Project Structure
```
src/main/kotlin/
├── controller/         # @RestController classes
├── service/            # Business logic (suspend functions)
├── repository/         # R2DBC repositories
├── model/              # Domain entities
├── dto/                # Data transfer objects
├── config/             # @Configuration classes
└── Application.kt      # Main class

src/test/kotlin/
├── controller/         # Controller tests
├── service/            # Service specs
├── repository/         # Repository tests
└── integration/        # E2E tests
```

## Kotlin Conventions

### Naming
- Classes: PascalCase
- Functions/Properties: camelCase
- Constants: SCREAMING_SNAKE_CASE
- Files: match class name

### Function Patterns
```kotlin
// Suspend for one-shot async
suspend fun findById(id: Long): Entity?

// Flow for streaming
fun findAll(): Flow<Entity>

// Expression body for simple functions
fun toDto() = EntityDto(id, name, price)
```

# ═══════════════════════════════════════════════════════════════════════════════
# AGENT REGISTRY
# ═══════════════════════════════════════════════════════════════════════════════

## Available Agents

### code-reviewer
- Focus: Kotlin idioms, reactive patterns
- Skills: kotlin-idioms, grounding
- Checks: null safety, coroutine usage, data classes

### test-generator
- Focus: Kotest specs with MockK
- Skills: tdd
- Output: FunSpec or BehaviorSpec tests

## Available Skills

### bugfix-workflow
- Purpose: GitHub issue-driven fixes
- Trigger: Issue reference

### feature-workflow
- Purpose: Feature implementation
- Flow: Entity → Repository → Service → Controller → Tests

### tdd
- Purpose: Test-driven development
- Pattern: Kotest spec first → implement → refactor

# ═══════════════════════════════════════════════════════════════════════════════
# KNOWLEDGE FILES
# ═══════════════════════════════════════════════════════════════════════════════

## Reference Data
- knowledge/kotlin-idioms.json - Kotlin idiomatic patterns
- knowledge/spring-kotlin-patterns.json - Spring Boot with Kotlin
- knowledge/coroutines-patterns.json - Coroutines patterns
- knowledge/kotest-patterns.json - Kotest testing patterns

# ═══════════════════════════════════════════════════════════════════════════════
# BEHAVIOR RULES
# ═══════════════════════════════════════════════════════════════════════════════

## Code Generation Rules
1. Always use data class for DTOs
2. Always use suspend for one-shot operations
3. Always use Flow for streaming operations
4. Never use blocking calls in reactive code
5. Always use null safety operators

## Review Rules
1. Check for platform types
2. Verify coroutine context usage
3. Ensure proper null handling
4. Validate reactive patterns
5. Check for Kotlin idioms

## Testing Rules
1. Use Kotest FunSpec or BehaviorSpec
2. Use MockK for mocking
3. Use coEvery/coVerify for suspend mocks
4. Test both success and error paths
