# Product Catalog API - Cursor Agent Rules
# Generated by Cursor Agent Factory
# 5-Layer Architecture: Integrity → Purpose → Principles → Methodology → Technical

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 0: INTEGRITY & LOGIC (Axioms)
# ═══════════════════════════════════════════════════════════════════════════════

## Core Axioms (Immutable)

### A1: Verifiability
All agent outputs must be verifiable against source:
- All code changes traceable to work items
- Business logic covered by unit tests
- Integration tests verify API contracts

### A2: User Primacy
User intent takes precedence:
- API consumers' needs drive design
- Breaking changes require versioning
- Clear error messages for clients

### A3: Transparency
Agent reasoning must be explainable:
- Architecture decisions documented
- Layer dependencies clear
- Code is self-documenting

### A4: Non-Harm
No action may knowingly cause harm:
- Secure by default
- Input validation on all endpoints
- No sensitive data exposure

### A5: Consistency
No rule may contradict these axioms:
- Consistent patterns across layers
- Uniform error handling
- Standard naming conventions

## Optional Axioms (Selected)

### A6: Minimalism
Prefer the simplest solution:
- No gold-plating
- YAGNI principle
- Essential complexity only

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 1: PURPOSE
# ═══════════════════════════════════════════════════════════════════════════════

## Mission
To accelerate enterprise API development with Clean Architecture patterns,
ensuring maintainability and testability.

## Primary Stakeholders
.NET developers building enterprise APIs in a team of 4-8 engineers.

## Success Criteria
Achieve 90% test coverage on business logic while maintaining Clean Architecture
compliance.

## Purpose Alignment Check
Before implementing:
- Does this maintain layer separation?
- Is business logic in the right layer?
- Are dependencies pointing inward?

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 2: PRINCIPLES
# ═══════════════════════════════════════════════════════════════════════════════

## Quality Standards

### Code Quality
- Nullable reference types enabled
- No compiler warnings
- SonarAnalyzer rules enforced
- XML documentation on public APIs

### Architecture Quality
- Domain layer has zero dependencies
- Application layer depends only on Domain
- Infrastructure implements Domain interfaces
- API configures dependency injection

### Testing Quality
- 90% coverage on Application and Domain
- Integration tests for all endpoints
- Mock external dependencies
- Use FluentAssertions

## Clean Architecture Rules

### Dependency Flow
```
API → Application → Domain ← Infrastructure
```

### Layer Responsibilities
- **Domain**: Entities, Value Objects, Domain Events
- **Application**: Commands, Queries, DTOs, Validators
- **Infrastructure**: DbContext, Repositories, External Services
- **API**: Controllers, Middleware, DI Configuration

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 3: METHODOLOGY
# ═══════════════════════════════════════════════════════════════════════════════

## Development Methodology: Agile Scrum

### Sprint Configuration
- Sprint Length: 2 weeks
- Team Size: 4-8 developers

### Ceremonies
- Sprint Planning: Define sprint goal and backlog
- Daily Standup: 15 minutes, async-first
- Sprint Review: Demo to stakeholders
- Retrospective: Continuous improvement

### Code Review Requirements
- At least 1 approver
- Clean Architecture compliance check
- Test coverage verified
- Security review for auth changes

# ═══════════════════════════════════════════════════════════════════════════════
# LAYER 4: TECHNICAL
# ═══════════════════════════════════════════════════════════════════════════════

## Technology Stack

### Framework
- ASP.NET Core 8+
- C# 12

### Data Access
- Entity Framework Core 8
- SQL Server (prod) / SQLite (dev)

### Patterns
- CQRS with MediatR
- Repository Pattern
- Unit of Work

### Validation
- FluentValidation
- Data Annotations (fallback)

### Testing
- xUnit
- NSubstitute
- FluentAssertions
- TestContainers (integration)

## Project Structure
```
src/
├── Api/
│   ├── Controllers/          # API endpoints
│   ├── Middleware/           # Cross-cutting concerns
│   ├── Filters/              # Exception handling
│   └── Program.cs            # DI configuration
├── Application/
│   ├── Commands/             # Write operations
│   ├── Queries/              # Read operations
│   ├── DTOs/                 # Data transfer objects
│   ├── Validators/           # FluentValidation
│   ├── Behaviors/            # MediatR pipelines
│   └── Mappings/             # AutoMapper profiles
├── Domain/
│   ├── Entities/             # Business entities
│   ├── ValueObjects/         # Immutable values
│   ├── Enums/                # Domain enums
│   ├── Events/               # Domain events
│   ├── Exceptions/           # Domain exceptions
│   └── Interfaces/           # Repository contracts
└── Infrastructure/
    ├── Data/                 # DbContext, migrations
    ├── Repositories/         # Repository implementations
    └── Services/             # External service clients
```

## Naming Conventions

### C# Conventions
- PascalCase for public members
- _camelCase for private fields
- I prefix for interfaces
- Async suffix for async methods

### CQRS Conventions
- Commands: VerbNounCommand (CreateProductCommand)
- Queries: GetNounQuery (GetProductByIdQuery)
- Handlers: CommandHandler, QueryHandler

# ═══════════════════════════════════════════════════════════════════════════════
# AGENT REGISTRY
# ═══════════════════════════════════════════════════════════════════════════════

## Available Agents

### code-reviewer
- Focus: Clean Architecture compliance, C# best practices
- Skills: grounding, code-review

### test-generator
- Focus: xUnit tests with NSubstitute and FluentAssertions
- Skills: tdd, grounding

### documentation-agent
- Focus: XML docs, OpenAPI, README
- Skills: documentation

## Available Skills

### bugfix-workflow
- Purpose: Azure DevOps-driven bug fixes
- Trigger: Work item reference

### feature-workflow
- Purpose: Feature implementation with CQRS
- Flow: Command/Query → Handler → Tests

### tdd
- Purpose: Test-driven development
- Flow: Test → Implement → Refactor

### security-audit
- Purpose: Security vulnerability detection
- Focus: OWASP Top 10, authentication, authorization

# ═══════════════════════════════════════════════════════════════════════════════
# KNOWLEDGE FILES
# ═══════════════════════════════════════════════════════════════════════════════

## Reference Data
- knowledge/clean-architecture.json - Layer patterns and rules
- knowledge/csharp-conventions.json - C# naming and style
- knowledge/efcore-patterns.json - Entity Framework patterns
- knowledge/cqrs-patterns.json - MediatR command/query patterns

# ═══════════════════════════════════════════════════════════════════════════════
# BEHAVIOR RULES
# ═══════════════════════════════════════════════════════════════════════════════

## Architecture Rules
1. Domain layer must have zero package dependencies
2. Application can only reference Domain
3. Infrastructure implements Domain interfaces
4. API only calls Application layer (via MediatR)

## CQRS Rules
1. Commands modify state, return result or void
2. Queries read state, return DTOs
3. Handlers are single-responsibility
4. Validators run before handlers (pipeline behavior)

## Testing Rules
1. Unit test all handlers
2. Mock repositories in unit tests
3. Use real database in integration tests
4. Test both happy path and error cases
