{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Agent Coordination Patterns",
  "description": "Patterns for coordinating multiple AI agents in collaborative systems",
  "version": "1.0.0",
  "axiomAlignment": {
    "A2_user_primacy": "Coordination patterns ensure user intent is fulfilled effectively",
    "A3_transparency": "Clear coordination makes multi-agent behavior predictable"
  },
  "coordination_patterns": {
    "peer_collaboration": {
      "description": "Agents work as equals, reviewing each other's output",
      "use_when": [
        "Tasks benefit from multiple perspectives",
        "Quality improvement through critique",
        "Creative problem-solving"
      ],
      "structure": {
        "communication": "broadcast",
        "decision": "consensus_or_voting",
        "conflict_resolution": "voting_or_mediator"
      },
      "implementation": {
        "message_format": {
          "from": "agent_id",
          "to": "all | specific_agent",
          "content": "message",
          "type": "proposal | critique | agreement | question"
        },
        "consensus_protocol": "Require agreement from majority before finalizing"
      },
      "example_use_cases": [
        "Code review with multiple reviewers",
        "Design brainstorming",
        "Research paper writing"
      ],
      "best_practices": [
        "Define clear roles even among peers",
        "Set iteration limits for consensus",
        "Include tie-breaking mechanism"
      ]
    },
    "hierarchical_command": {
      "description": "Supervisor agent coordinates worker agents",
      "use_when": [
        "Complex tasks requiring decomposition",
        "Clear authority structure needed",
        "Resource allocation decisions"
      ],
      "structure": {
        "communication": "top_down_directives",
        "decision": "supervisor_authority",
        "conflict_resolution": "escalation_to_supervisor"
      },
      "implementation": {
        "supervisor_responsibilities": [
          "Task decomposition",
          "Worker selection",
          "Progress monitoring",
          "Result aggregation"
        ],
        "worker_responsibilities": [
          "Execute assigned tasks",
          "Report status",
          "Request clarification when needed"
        ]
      },
      "example_use_cases": [
        "Large codebase refactoring",
        "Multi-file feature implementation",
        "Complex debugging"
      ],
      "best_practices": [
        "Keep supervisor focused on coordination, not execution",
        "Define clear handoff protocols",
        "Implement timeout handling for workers"
      ]
    },
    "pipeline_processing": {
      "description": "Sequential handoff between specialized agents",
      "use_when": [
        "Tasks have clear sequential stages",
        "Each stage requires different expertise",
        "Output of one stage is input to next"
      ],
      "structure": {
        "communication": "handoff_with_context",
        "decision": "stage_owner_authority",
        "conflict_resolution": "pipeline_coordinator"
      },
      "implementation": {
        "handoff_protocol": {
          "output": "Stage output",
          "context": "Relevant context for next stage",
          "status": "complete | needs_revision | blocked"
        },
        "stages_example": ["Extract", "Transform", "Validate", "Apply"]
      },
      "example_use_cases": [
        "ETL pipelines",
        "Code generation with review",
        "Document processing"
      ],
      "best_practices": [
        "Define clear interfaces between stages",
        "Allow backward flow for revisions",
        "Include validation at each handoff"
      ]
    },
    "knowledge_mesh": {
      "description": "Agents share knowledge dynamically",
      "use_when": [
        "Research and exploration tasks",
        "Knowledge discovery",
        "Collaborative learning"
      ],
      "structure": {
        "communication": "shared_knowledge_base",
        "decision": "expertise_based",
        "conflict_resolution": "evidence_evaluation"
      },
      "implementation": {
        "knowledge_sharing": {
          "publish": "Agent publishes findings to shared store",
          "subscribe": "Agents subscribe to relevant topics",
          "query": "Agents query shared knowledge as needed"
        },
        "expertise_routing": "Route questions to agent with most relevant expertise"
      },
      "example_use_cases": [
        "Research literature review",
        "Codebase exploration",
        "Documentation generation"
      ],
      "best_practices": [
        "Curate shared knowledge to prevent noise",
        "Tag knowledge with confidence levels",
        "Implement knowledge decay for outdated info"
      ]
    },
    "consensus_reaching": {
      "description": "Agents must agree before proceeding",
      "use_when": [
        "High-stakes decisions",
        "Diverse perspectives needed",
        "Quality assurance"
      ],
      "structure": {
        "communication": "proposal_and_feedback",
        "decision": "unanimous_or_majority",
        "conflict_resolution": "deliberation_rounds"
      },
      "implementation": {
        "protocol": [
          "Agent proposes solution",
          "Other agents provide feedback",
          "Proposer revises based on feedback",
          "Vote on final proposal",
          "Accept if threshold met, else iterate"
        ],
        "voting_options": ["accept", "reject", "abstain"]
      },
      "example_use_cases": [
        "Architecture decisions",
        "Security-critical changes",
        "Production deployments"
      ],
      "best_practices": [
        "Set maximum deliberation rounds",
        "Allow escalation to human if no consensus",
        "Document dissenting opinions"
      ]
    },
    "blackboard": {
      "description": "Shared workspace where agents contribute solutions",
      "use_when": [
        "Problem can be solved incrementally",
        "Multiple solution approaches possible",
        "Opportunistic contribution"
      ],
      "structure": {
        "communication": "read_write_shared_board",
        "decision": "best_contribution_wins",
        "conflict_resolution": "quality_based_selection"
      },
      "implementation": {
        "blackboard_structure": {
          "problem": "Current problem description",
          "partial_solutions": "List of contributions",
          "solution": "Current best solution",
          "metadata": "Quality scores, contributors"
        },
        "contribution_protocol": "Any agent can contribute; controller evaluates"
      },
      "example_use_cases": [
        "Complex debugging",
        "Creative problem solving",
        "Multi-approach optimization"
      ]
    }
  },
  "communication_protocols": {
    "message_types": {
      "request": "Ask another agent to do something",
      "inform": "Share information without expecting action",
      "propose": "Suggest a course of action for consideration",
      "accept": "Agree to a proposal",
      "reject": "Decline a proposal with reason",
      "query": "Ask for information",
      "confirm": "Verify understanding"
    },
    "message_structure": {
      "id": "Unique message identifier",
      "from": "Sender agent ID",
      "to": "Recipient agent ID or 'all'",
      "type": "Message type from types above",
      "content": "Message payload",
      "in_reply_to": "ID of message being responded to",
      "timestamp": "When message was sent"
    },
    "conversation_patterns": {
      "request_response": "Agent A requests -> Agent B responds",
      "negotiation": "Propose -> Counter-propose -> Accept/Reject",
      "broadcast": "Agent A informs all -> Others acknowledge",
      "subscription": "Agent A subscribes to topic -> Publisher agents notify"
    }
  },
  "conflict_resolution": {
    "authority_based": {
      "description": "Higher authority agent decides",
      "use_when": "Clear hierarchy exists",
      "implementation": "Escalate to supervisor or designated authority"
    },
    "voting_based": {
      "description": "Majority or consensus vote",
      "use_when": "Peer agents with equal authority",
      "implementation": "Collect votes, apply threshold"
    },
    "evidence_based": {
      "description": "Decision based on supporting evidence",
      "use_when": "Objective criteria available",
      "implementation": "Compare evidence quality and quantity"
    },
    "human_escalation": {
      "description": "Escalate to human for decision",
      "use_when": "Stakes too high for autonomous decision",
      "implementation": "Pause workflow, present options to human",
      "axiom_alignment": "A2 (User Primacy) - Defer to human for critical decisions"
    }
  },
  "state_management": {
    "shared_state": {
      "description": "All agents share common state",
      "implementation": "Central state store (e.g., LangGraph state)",
      "considerations": [
        "Concurrency control needed",
        "Clear ownership of state sections",
        "State versioning for debugging"
      ]
    },
    "message_passing": {
      "description": "Agents communicate via messages only",
      "implementation": "Message queue or event bus",
      "considerations": [
        "More decoupled",
        "Easier to test independently",
        "May need state reconstruction from messages"
      ]
    },
    "hybrid": {
      "description": "Shared state for coordination, messages for tasks",
      "implementation": "Combine approaches based on need",
      "considerations": [
        "Best of both worlds",
        "More complex implementation"
      ]
    }
  },
  "implementation_with_langgraph": {
    "multi_agent_graph": {
      "description": "Multiple agent nodes in single graph",
      "code_example": "graph = StateGraph(State)\ngraph.add_node('agent_a', agent_a_node)\ngraph.add_node('agent_b', agent_b_node)\ngraph.add_node('coordinator', coordinator_node)\n# Coordinator routes between agents"
    },
    "subgraph_composition": {
      "description": "Compose multiple agent graphs",
      "use_when": "Complex agents that need their own internal graphs",
      "code_example": "agent_a_graph = create_agent_a_graph()\nagent_b_graph = create_agent_b_graph()\n\ndef agent_a_node(state):\n    return agent_a_graph.invoke(state)\n\nmain_graph.add_node('agent_a', agent_a_node)"
    }
  },
  "best_practices": {
    "general": [
      "Define clear agent responsibilities",
      "Establish explicit communication protocols",
      "Implement timeout and retry logic",
      "Log all inter-agent communication",
      "Test agents independently before integration"
    ],
    "scalability": [
      "Consider async communication for I/O-bound tasks",
      "Implement backpressure mechanisms",
      "Monitor agent resource usage"
    ],
    "reliability": [
      "Handle partial failures gracefully",
      "Implement circuit breakers for failing agents",
      "Design for idempotency where possible"
    ]
  }
}
