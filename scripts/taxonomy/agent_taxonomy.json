{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Agent Building Topic Taxonomy",
  "description": "Structured ontology defining required knowledge for AI agent development",
  "version": "1.0.0",
  "metadata": {
    "created": "2026-01-31",
    "purpose": "Guide autonomous knowledge extension for agent-related topics",
    "coverage_scale": {
      "0": "Not covered - no mention in knowledge base",
      "1": "Mentioned - referenced but not explained",
      "2": "Covered - basic explanation with examples",
      "3": "Deep - comprehensive coverage with patterns, anti-patterns, best practices"
    },
    "required_depth_meanings": {
      "1": "Brief mention is sufficient",
      "2": "Requires explanation and basic examples",
      "3": "Requires comprehensive coverage with code examples"
    }
  },
  "domains": {
    "agent_architecture": {
      "description": "Core patterns for building AI agents",
      "required_depth": 3,
      "knowledge_files": ["langchain-patterns.json", "multi-agent-patterns.json"],
      "topics": {
        "design_patterns": {
          "required_depth": 3,
          "subtopics": {
            "react_pattern": {
              "description": "Reasoning and Acting - agent thinks then acts",
              "keywords": ["react", "reason", "act", "thought", "observation"],
              "required_depth": 3
            },
            "plan_execute_pattern": {
              "description": "Plan first, then execute steps",
              "keywords": ["plan", "execute", "planning", "step-by-step"],
              "required_depth": 3
            },
            "reflection_pattern": {
              "description": "Agent reflects on and improves its outputs",
              "keywords": ["reflection", "self-critique", "improvement", "iterate"],
              "required_depth": 3
            },
            "tool_calling_pattern": {
              "description": "Native function/tool calling capabilities",
              "keywords": ["tool", "function", "calling", "bind_tools"],
              "required_depth": 3
            },
            "retrieval_augmented_pattern": {
              "description": "Agents with RAG capabilities",
              "keywords": ["rag", "retrieval", "augmented", "grounding"],
              "required_depth": 3
            },
            "conversational_pattern": {
              "description": "Stateful conversation with memory",
              "keywords": ["conversation", "chat", "memory", "history"],
              "required_depth": 2
            }
          }
        },
        "memory_systems": {
          "required_depth": 3,
          "subtopics": {
            "buffer_memory": {
              "description": "Full conversation history storage",
              "keywords": ["buffer", "full history", "conversation buffer"],
              "required_depth": 2
            },
            "summary_memory": {
              "description": "Summarized conversation for token efficiency",
              "keywords": ["summary", "summarize", "condensed"],
              "required_depth": 2
            },
            "window_memory": {
              "description": "Sliding window of recent messages",
              "keywords": ["window", "recent", "last k"],
              "required_depth": 2
            },
            "vector_memory": {
              "description": "Semantic retrieval of past interactions",
              "keywords": ["vector", "embedding", "semantic", "retrieval"],
              "required_depth": 3
            },
            "entity_memory": {
              "description": "Track entities and their attributes",
              "keywords": ["entity", "entities", "attributes", "facts"],
              "required_depth": 2
            },
            "long_term_memory": {
              "description": "Persistent memory across sessions",
              "keywords": ["long-term", "persistent", "database", "storage"],
              "required_depth": 3
            }
          }
        },
        "orchestration_patterns": {
          "required_depth": 3,
          "subtopics": {
            "sequential": {
              "description": "Agents/steps execute in order",
              "keywords": ["sequential", "pipeline", "chain"],
              "required_depth": 2
            },
            "parallel": {
              "description": "Concurrent execution of independent tasks",
              "keywords": ["parallel", "concurrent", "simultaneous"],
              "required_depth": 2
            },
            "hierarchical": {
              "description": "Manager delegates to worker agents",
              "keywords": ["hierarchical", "manager", "worker", "delegation"],
              "required_depth": 3
            },
            "supervisor": {
              "description": "Supervisor routes and coordinates workers",
              "keywords": ["supervisor", "router", "coordinator"],
              "required_depth": 3
            },
            "swarm": {
              "description": "Decentralized agent coordination",
              "keywords": ["swarm", "decentralized", "emergent"],
              "required_depth": 2
            }
          }
        }
      }
    },
    "multi_agent_frameworks": {
      "description": "Frameworks for building multi-agent systems",
      "required_depth": 3,
      "knowledge_files": ["crewai-patterns.json", "autogen-patterns.json", "langgraph-workflows.json", "multi-agent-patterns.json"],
      "topics": {
        "crewai": {
          "required_depth": 3,
          "subtopics": {
            "agent_definition": {
              "description": "Role, goal, backstory patterns",
              "keywords": ["agent", "role", "goal", "backstory"],
              "required_depth": 3
            },
            "task_design": {
              "description": "Task definition and dependencies",
              "keywords": ["task", "expected_output", "context", "dependencies"],
              "required_depth": 3
            },
            "crew_orchestration": {
              "description": "Crew process types and management",
              "keywords": ["crew", "process", "sequential", "hierarchical"],
              "required_depth": 3
            },
            "tools_integration": {
              "description": "CrewAI tools and custom tools",
              "keywords": ["tools", "crewai_tools", "@tool"],
              "required_depth": 2
            }
          }
        },
        "autogen": {
          "required_depth": 3,
          "subtopics": {
            "assistant_agent": {
              "description": "AssistantAgent configuration",
              "keywords": ["AssistantAgent", "system_message", "llm_config"],
              "required_depth": 3
            },
            "user_proxy": {
              "description": "UserProxyAgent and code execution",
              "keywords": ["UserProxyAgent", "human_input_mode", "code_execution"],
              "required_depth": 3
            },
            "group_chat": {
              "description": "Multi-agent group conversations",
              "keywords": ["GroupChat", "GroupChatManager", "speaker_selection"],
              "required_depth": 3
            },
            "teachable_agent": {
              "description": "Agents that learn from feedback",
              "keywords": ["TeachableAgent", "learn", "teach"],
              "required_depth": 2
            }
          }
        },
        "langgraph": {
          "required_depth": 3,
          "subtopics": {
            "state_graph": {
              "description": "StateGraph definition and nodes",
              "keywords": ["StateGraph", "add_node", "add_edge"],
              "required_depth": 3
            },
            "conditional_edges": {
              "description": "Conditional routing between nodes",
              "keywords": ["conditional_edges", "router", "branching"],
              "required_depth": 3
            },
            "checkpointing": {
              "description": "State persistence and resumption",
              "keywords": ["checkpointer", "checkpoint", "persist", "resume"],
              "required_depth": 3
            },
            "human_in_loop": {
              "description": "Human intervention points",
              "keywords": ["interrupt_before", "human", "approval"],
              "required_depth": 2
            },
            "subgraphs": {
              "description": "Nested graphs for modularity",
              "keywords": ["subgraph", "nested", "modular"],
              "required_depth": 2
            }
          }
        },
        "openai_agents_sdk": {
          "required_depth": 2,
          "subtopics": {
            "agent_definition": {
              "description": "OpenAI Agents SDK agent creation",
              "keywords": ["Agent", "instructions", "model"],
              "required_depth": 2
            },
            "handoffs": {
              "description": "Agent-to-agent handoffs",
              "keywords": ["handoff", "transfer", "delegate"],
              "required_depth": 2
            },
            "guardrails": {
              "description": "Input/output validation",
              "keywords": ["guardrail", "validation", "safety"],
              "required_depth": 2
            }
          }
        }
      }
    },
    "tool_building": {
      "description": "Creating and managing agent tools",
      "required_depth": 3,
      "knowledge_files": ["langchain-patterns.json", "mcp-patterns.json"],
      "topics": {
        "tool_definition": {
          "required_depth": 3,
          "subtopics": {
            "decorator_pattern": {
              "description": "@tool decorator usage",
              "keywords": ["@tool", "decorator", "tool function"],
              "required_depth": 3
            },
            "structured_tools": {
              "description": "Pydantic schemas for tool inputs",
              "keywords": ["StructuredTool", "args_schema", "Pydantic"],
              "required_depth": 3
            },
            "async_tools": {
              "description": "Asynchronous tool implementation",
              "keywords": ["async", "await", "aiohttp"],
              "required_depth": 2
            },
            "error_handling": {
              "description": "Tool error handling strategies",
              "keywords": ["error", "exception", "fallback", "retry"],
              "required_depth": 3
            }
          }
        },
        "mcp_servers": {
          "required_depth": 3,
          "subtopics": {
            "server_architecture": {
              "description": "MCP server design principles",
              "keywords": ["MCP", "server", "protocol"],
              "required_depth": 3
            },
            "tool_exposure": {
              "description": "Exposing tools via MCP",
              "keywords": ["list_tools", "call_tool", "Tool"],
              "required_depth": 3
            },
            "resource_management": {
              "description": "MCP resources and templates",
              "keywords": ["resources", "templates", "uri"],
              "required_depth": 2
            },
            "client_integration": {
              "description": "Connecting MCP clients to servers",
              "keywords": ["client", "transport", "stdio", "sse"],
              "required_depth": 2
            }
          }
        }
      }
    },
    "prompt_engineering": {
      "description": "Effective prompting for agents",
      "required_depth": 3,
      "knowledge_files": ["prompt-engineering.json", "prompt-library.json"],
      "topics": {
        "system_prompts": {
          "required_depth": 3,
          "subtopics": {
            "identity_section": {
              "description": "Defining agent identity and purpose",
              "keywords": ["identity", "role", "purpose", "you are"],
              "required_depth": 3
            },
            "capability_section": {
              "description": "Specifying what agent can/cannot do",
              "keywords": ["capabilities", "can", "cannot", "limitations"],
              "required_depth": 2
            },
            "constraint_section": {
              "description": "Behavioral constraints and rules",
              "keywords": ["constraints", "rules", "must", "never"],
              "required_depth": 3
            },
            "output_format": {
              "description": "Defining response structure",
              "keywords": ["format", "structure", "output", "respond"],
              "required_depth": 3
            }
          }
        },
        "prompting_techniques": {
          "required_depth": 3,
          "subtopics": {
            "few_shot": {
              "description": "Learning from examples",
              "keywords": ["few-shot", "examples", "demonstration"],
              "required_depth": 3
            },
            "chain_of_thought": {
              "description": "Step-by-step reasoning",
              "keywords": ["chain of thought", "CoT", "step by step", "reasoning"],
              "required_depth": 3
            },
            "tree_of_thoughts": {
              "description": "Branching reasoning paths",
              "keywords": ["tree of thoughts", "ToT", "branching", "exploration"],
              "required_depth": 2
            },
            "self_consistency": {
              "description": "Multiple reasoning paths aggregation",
              "keywords": ["self-consistency", "multiple", "voting", "aggregate"],
              "required_depth": 2
            },
            "structured_output": {
              "description": "Forcing structured responses",
              "keywords": ["structured", "JSON", "schema", "Pydantic"],
              "required_depth": 3
            }
          }
        }
      }
    },
    "rag_systems": {
      "description": "Retrieval-Augmented Generation",
      "required_depth": 3,
      "knowledge_files": ["rag-patterns.json", "vector-database-patterns.json"],
      "topics": {
        "indexing": {
          "required_depth": 3,
          "subtopics": {
            "chunking_strategies": {
              "description": "Document splitting approaches",
              "keywords": ["chunk", "split", "recursive", "semantic"],
              "required_depth": 3
            },
            "embedding_models": {
              "description": "Text embedding selection",
              "keywords": ["embedding", "OpenAI", "sentence-transformers"],
              "required_depth": 2
            },
            "vector_stores": {
              "description": "Vector database options",
              "keywords": ["Chroma", "Pinecone", "FAISS", "vector store"],
              "required_depth": 3
            },
            "metadata_design": {
              "description": "Chunk metadata strategies",
              "keywords": ["metadata", "filtering", "source"],
              "required_depth": 2
            }
          }
        },
        "retrieval": {
          "required_depth": 3,
          "subtopics": {
            "similarity_search": {
              "description": "Basic vector similarity",
              "keywords": ["similarity", "cosine", "search"],
              "required_depth": 2
            },
            "mmr": {
              "description": "Maximum Marginal Relevance",
              "keywords": ["MMR", "diversity", "marginal relevance"],
              "required_depth": 2
            },
            "hybrid_search": {
              "description": "Vector + keyword search",
              "keywords": ["hybrid", "BM25", "ensemble"],
              "required_depth": 3
            },
            "reranking": {
              "description": "Cross-encoder reranking",
              "keywords": ["rerank", "cross-encoder", "Cohere"],
              "required_depth": 3
            },
            "query_transformation": {
              "description": "Query rewriting and expansion",
              "keywords": ["multi-query", "HyDE", "expansion"],
              "required_depth": 2
            }
          }
        },
        "generation": {
          "required_depth": 2,
          "subtopics": {
            "context_injection": {
              "description": "Adding context to prompts",
              "keywords": ["context", "inject", "augment"],
              "required_depth": 2
            },
            "citation": {
              "description": "Source attribution in responses",
              "keywords": ["citation", "source", "reference"],
              "required_depth": 2
            },
            "hallucination_prevention": {
              "description": "Grounding and fact-checking",
              "keywords": ["hallucination", "grounding", "verify"],
              "required_depth": 3
            }
          }
        }
      }
    },
    "agent_evaluation": {
      "description": "Testing and evaluating agent performance",
      "required_depth": 3,
      "knowledge_files": ["llm-evaluation-patterns.json", "agent-testing.json"],
      "topics": {
        "evaluation_metrics": {
          "required_depth": 3,
          "subtopics": {
            "task_completion": {
              "description": "Measuring task success rate",
              "keywords": ["completion", "success", "rate", "accuracy"],
              "required_depth": 3
            },
            "trajectory_analysis": {
              "description": "Evaluating agent decision paths",
              "keywords": ["trajectory", "path", "steps", "decisions"],
              "required_depth": 2
            },
            "tool_usage": {
              "description": "Tool selection accuracy",
              "keywords": ["tool usage", "correct tool", "selection"],
              "required_depth": 2
            },
            "response_quality": {
              "description": "Answer quality metrics",
              "keywords": ["quality", "relevance", "coherence"],
              "required_depth": 2
            }
          }
        },
        "testing_strategies": {
          "required_depth": 3,
          "subtopics": {
            "unit_testing": {
              "description": "Testing individual components",
              "keywords": ["unit test", "mock", "isolated"],
              "required_depth": 3
            },
            "integration_testing": {
              "description": "End-to-end agent testing",
              "keywords": ["integration", "end-to-end", "e2e"],
              "required_depth": 3
            },
            "benchmark_suites": {
              "description": "Standard evaluation benchmarks",
              "keywords": ["benchmark", "GAIA", "AgentBench"],
              "required_depth": 2
            },
            "regression_testing": {
              "description": "Preventing capability regression",
              "keywords": ["regression", "golden", "baseline"],
              "required_depth": 2
            }
          }
        },
        "observability": {
          "required_depth": 3,
          "subtopics": {
            "tracing": {
              "description": "Execution trace collection",
              "keywords": ["trace", "LangSmith", "observability"],
              "required_depth": 3
            },
            "logging": {
              "description": "Structured logging for agents",
              "keywords": ["logging", "callback", "handler"],
              "required_depth": 2
            },
            "monitoring": {
              "description": "Production monitoring",
              "keywords": ["monitoring", "metrics", "alerting"],
              "required_depth": 2
            }
          }
        }
      }
    },
    "production_deployment": {
      "description": "Deploying agents to production",
      "required_depth": 2,
      "knowledge_files": ["model-serving-patterns.json", "mlops-patterns.json"],
      "topics": {
        "serving": {
          "required_depth": 2,
          "subtopics": {
            "api_design": {
              "description": "Agent API patterns",
              "keywords": ["API", "REST", "streaming"],
              "required_depth": 2
            },
            "scaling": {
              "description": "Horizontal and vertical scaling",
              "keywords": ["scaling", "load balancing", "horizontal"],
              "required_depth": 2
            },
            "caching": {
              "description": "Response and embedding caching",
              "keywords": ["cache", "Redis", "embedding cache"],
              "required_depth": 2
            }
          }
        },
        "safety": {
          "required_depth": 3,
          "subtopics": {
            "input_validation": {
              "description": "Prompt injection prevention",
              "keywords": ["injection", "validation", "sanitize"],
              "required_depth": 3
            },
            "output_filtering": {
              "description": "Content safety filtering",
              "keywords": ["filter", "safety", "moderation"],
              "required_depth": 2
            },
            "guardrails": {
              "description": "Behavioral guardrails",
              "keywords": ["guardrails", "constraints", "boundaries"],
              "required_depth": 3
            },
            "rate_limiting": {
              "description": "Request throttling",
              "keywords": ["rate limit", "throttle", "quota"],
              "required_depth": 2
            }
          }
        }
      }
    },
    "constitutional_ai": {
      "description": "Axiom-based and constitutional AI approaches",
      "required_depth": 2,
      "knowledge_files": [],
      "topics": {
        "axiom_systems": {
          "required_depth": 2,
          "subtopics": {
            "axiom_definition": {
              "description": "Defining behavioral axioms",
              "keywords": ["axiom", "principle", "rule", "constraint"],
              "required_depth": 2
            },
            "axiom_alignment": {
              "description": "Aligning outputs with axioms",
              "keywords": ["alignment", "verify", "comply"],
              "required_depth": 2
            },
            "conflict_resolution": {
              "description": "Resolving axiom conflicts",
              "keywords": ["conflict", "priority", "resolution"],
              "required_depth": 2
            }
          }
        },
        "self_critique": {
          "required_depth": 2,
          "subtopics": {
            "critique_generation": {
              "description": "Agent self-critique patterns",
              "keywords": ["critique", "self-review", "evaluate"],
              "required_depth": 2
            },
            "revision_loops": {
              "description": "Iterative improvement",
              "keywords": ["revision", "iterate", "improve"],
              "required_depth": 2
            }
          }
        }
      }
    }
  }
}
